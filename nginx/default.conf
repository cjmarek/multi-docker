# this configuration file is where routing rules for nginx come from.
#  http requests come into here and get funneled back out to the upstream client(s)
# We are using this nginx server as a common backend to direct routing
# By default, React apps use port 3000. (for that reason you don't see a 'listening on' statement in React)
# So because we explicitly have this as port 3000 (server client:3000) inside the container, and by default, React apps use port 3000,
# when we get our '/' request forwarded here at line 44, Voila! The React application starts up!
# Note, 'client' is the name we are using in the docker-compose.yml file
#  see    bottom of   ------> Complex-Checkpoint.png <-------
upstream client {
  server client:3000;
}
# Note, 'apifoo' is the name we are using in the docker-compose.yml file
# In this project, we are using port 5000 for Express
# The Express 'server' that is identified as 'apifoo' in the docker-compose.yml is assigned port 5000, at the bottom of server container index.js!!!!
# when we get our '/whatever' request forwarded here at line 60, Voila! The node.js (index.js) application starts up!
upstream apifoo {
  server apifoo:5000;
}

# Another stupid thing that confuses everything, we use api as part of the route name, and we (Grider) also use api as the server container name. So I decided to rename the
# server container name to apifoo. Just to show api and apifoo means different things.

# this is port 80 inside the nginx container, it can be anything from 0 to infinity.
# On this network, there are requests being made by the React application to retrieve the index.html and the App.js (he mis-labeled as main.js his lesson graphics)
# Apparently, requests from React are '/' by default at start up, and are taken care of here by 'location /' to retrieve the index.html and the App.js

# Since nginx is the web server, that then is the start of everything. So we use https://localhost:3050 to kick off the web application.
# In the Docker-compose file, we decided the outside Port to be 3050 and then we map it (here) to Port 80 to perform the routing rules defined in here,
# (Port 80 is this container). So that means any http requests that come from https://localhost:3050 get mapped to 80 (here). 
# React natively is listening on port 3000, so after arriving here as a result of Docker-compose 3050:80, here at line 45 we redirect http requests from here (port 80) to 
# client (React) which is already listening on 3000 (see line 10 makes damn sure to use 3000).
# So to recap, outside http requests from port 3050 come in here (nginx) and are then funneled to port 3000 (see line 10), and the React app is listening on port 3000.
# nginx is the the traffic cop of the application. nginx is after all the actual web server instead of the 
# development server that I normally deal with. The 'client', (React application) is mentioned in line 9 as being at port 3000, which React always listens on by default.
# 
# The Express 'server' that is identified as 'apifoo' in the docker-compose.yml is assigned port 5000, at the bottom of server container index.js!!!!
# There are 3 requests made from the React app, and all of them have 'api' as part of the route. So those requests come in here.
# After the 'api' gets stripped off here, then next, the http requests now resemble the routes in the server container,
# so now the server container at port 5000 will pick up these 'groomed' requests.
# according to his Complex-Checkpoint.png, any requests coming here with just '/', retrieve React stuff like index.html and App.js (he mis-labeled App.js as main.js his lesson graphics)
server {
  listen 80;
# routing rules, mentioning the upstream server names, client and apifoo.
  location / {
    proxy_pass http://client;
  }
# This route (and above route) goes to the client endpoints. 
# If I have commented this out, and it can still work without it. This has something to do with the Web Socket fix, intended to make the app more efficient.
# This allows the browser and the running React application inside of it to maintain a connection to the dev react server that it likes to have.
# We do NOT need this to be present in the Production version of the Dockerfile
  location /ws {
    proxy_pass http://client;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "Upgrade";
  }
# This route goes to the api endpoints (apifoo). Endpoints get routed over to Express server endpoints in index.js in server folder.
# Routing rule that chops off the api part of the request path before forwarding on to the Express server.
# Note, apifoo is the container name we are using in the docker-compose.yml file for the Express server.
  location /api {
    rewrite /api/(.*) /$1 break;
    proxy_pass http://apifoo;
  }
}